(ns equilibrium.core-test
  (:require [midje.sweet :refer :all]
            [equilibrium.core :as eq :refer [+#2 *#2]]))


;; # Constructors

;; The macro eq/data defines a constructor. Constructors are
;; self-evaluating functions, i.e., functions that evaluate to
;; themselves. The macro takes any number of forms, each consisting of
;; a name and example arguments.
(eq/data (list ?val ?next)
         (empty))

;; Each such form defines a Clojure function that returns the original
;; s-expr, with the symbol replaced with the canonical
;; namespace/name#arity format. The function name is derived from the
;; constructor, with `#` followed by the arity (number of arguments)
;; added as suffix.
(fact
 (list#2 1 (list#2 (inc 1) (empty#0))) =>
 '(equilibrium.core-test/list#2 1 (equilibrium.core-test/list#2 2 (equilibrium.core-test/empty#0))))

;; # Equations
;; Equations are defined using the eq/= form.

;; ## Constants

;; When the left-hand-side of an equation is a symbol, the equation
;; defines this symbol, similar to a Clojure def.
(eq/= x 2)
(fact
 x => 2)

;; ## Uniform Functions

;; When the left-hand-side is a form, a function of the same name is
;; being defined. When the first argument to that form is a variable
;; (a symbol starting with `?`), the equation defines a _uniform
;; function_.

;; The Clojure function being defined receives a suffix that includes
;; a hash sign (`#`) followed by the function's arity (number of
;; arguments). This is to say that functions of the same name but
;; different arities are distinct.
(eq/= (f ?x) (+ ?x 2))
(fact
 (f#1 3) => 5)

;; ### Under the Hood

;; All functions (uniform functions included) are accompanied by two atoms:
;; - A _code_ atom (with the `-code` suffix), containing a vector of two elements -- the s-expressions on the two sides of the equation, and
;; - A _compiled_ atom (with the `-comp` suffix), containing a closure with the function definition.
(fact
 @f#1-code => '[(f ?x) (+ ?x 2)]
 @f#1-comp => fn?
 (@f#1-comp 4) => 6)

;; The compiled function in the `-comp` atom is the only actual
;; implementation of the function. The base function (without the
;; `-comp` suffix) is merely a proxy. If the function in the atom gets
;; updated, the meaning of the function changes.
(fact
 (reset! f#1-comp (fn [?x] (- ?x 2)))
 (f#1 3) => 1)

;; ## Polimorphic Functions

;; Polymorphic functions are defined across multiple equations, each
;; contributing a solution for the case where the first argument is of
;; a specific constructor.
(eq/= (sum (list ?v ?r)) (+ ?v (sum ?r)))
(eq/= (sum (empty)) 0)
(fact
 (sum#1 (list#2 1 (list#2 2 (empty#0)))) => 3)

;; ### Under the Hood

;; The `-code` and `-comp` atoms exist for polymorphic functions as
;; well, but this time, they contain maps. Instead of holding
;; expressions (`-code`) and closures (`-comp`), they hold maps for
;; which the keys are the canonical symbols generated by the different
;; constructors, and the values are either expressions or closures, as
;; appropriate.
(fact
 @sum#1-code => map?
 @sum#1-comp => map?
 (@sum#1-code 'equilibrium.core-test/list#2) => '[(sum (list ?v ?r)) (+ ?v (sum ?r))]
 (@sum#1-comp 'equilibrium.core-test/list#2) => fn?)

;; # Under the Hood

;; ## canonical-symbol

;; The `canonical-symbol` function takes a form, and returns a
;; canonical symbol of the form `namespace/name#arity`, representing
;; its name and arity.
(fact
 (eq/canonical-symbol '(list 1 (empty))) => 'equilibrium.core-test/list#2)

;; If the sequence is not a proper form, i.e., does not start with a
;; symbol, an exception is thrown.
(fact
 (eq/canonical-symbol '(1 2 3)) => (throws #"Symbol expected at the beginning of a form. '1' found in .*"))

;; If a symbol cannot be resolved for that arity, an exception is thrown.
(fact
 (eq/canonical-symbol '(+ 1 2 3)) => (throws #"Symbol [+] cannot be resolved for arity 3 in .*"))

;; ## to-clj

;; This function compiles an Equilibrium s-expression into a Clojure
;; one.

;; Literals are kept unchanged.
(fact
 (eq/to-clj 3) => 3
 (eq/to-clj "foo") => "foo")

;; In forms (sequences that begin with a symbol), a `#` followed by
;; the arity (number of args) is appended to the symbol. A full
;; namespace is extracted based on resolution.
(fact
 (eq/to-clj '(+ 1 2)) => '(equilibrium.core/+#2 1 2))

;; to-clj works recursively.
(fact
 (eq/to-clj '(+ (* 1 2) 3)) => '(equilibrium.core/+#2 (equilibrium.core/*#2 1 2) 3))

;; ### Special forms

;; The `if` form translates to a Clojure `if` form.
(fact
 (eq/to-clj '(if true (+ 1 2) 3)) => '(if true (equilibrium.core/+#2 1 2) 3))

;; ## lhs-to-clj

;; Unlike to-clj, which translates right-hand-side expressions (i.e.,
;; values), lhs-to-clj translates left-hand-side patterns.

;; It operates on a sequence of arguments. If all are valid variables, they are returned as a Clojure vector.
(fact
 (eq/lhs-to-clj '(?a ?b ?c)) => '[?a ?b ?c])

;; Literals and non-variable symbols are replaced with dummy variables. Nested sequences are taken as vectors.
(fact
 (eq/lhs-to-clj '(1 "two" (three ?four 5))) => '[$1 $2 [$3 ?four $5]]
 (provided
  (rand-int 1000000000) =streams=> [1 2 3 5]))
